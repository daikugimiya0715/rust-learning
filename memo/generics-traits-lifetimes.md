# ジェネリック型、トレイト、ライフタイム（10章）

## 10.1 ジェネリックデータ型

### ジェネリック関数
- 型パラメータ `<T>` で同じロジックを複数の型に適用できる
- ただし `T` に演算を使うにはトレイト境界が必要（例: `T: PartialOrd`）

### ジェネリックな構造体・列挙型
- `Point<T>` — 同一型のフィールド
- `Point<T, U>` — 異なる型のフィールド
- `Option<T>`, `Result<T, E>` も同じ仕組み

### ジェネリックなメソッド
- `impl<T> Point<T>` — 全型向けメソッド
- `impl Point<f32>` — 特定型のみのメソッド
- メソッド自体にも追加の型パラメータを持てる（`mixup` の例）

### 単相化 (monomorphization)
- コンパイラがジェネリクスを具体型ごとのコードに展開
- ランタイムコストはゼロ（ゼロコスト抽象化）

## 10.2 トレイト

### 定義と実装
- `trait Summary { fn summarize(&self) -> String; }` でインターフェースを定義
- 各型で `impl Summary for Tweet { ... }` のように実装

### デフォルト実装
- トレイトのメソッドに本体を書くとデフォルト実装になる
- 各型はオーバーライドも可能
- デフォルト実装から同じトレイト内の他メソッドを呼べる

### トレイト境界（3つの構文）
| 構文 | 例 | 使い分け |
|---|---|---|
| `impl Trait` | `fn f(x: &impl Display)` | 短く簡潔 |
| `<T: Trait>` | `fn f<T: Display>(x: &T)` | 同じ型を複数箇所で使う場合 |
| `where` 句 | `fn f<T>(x: &T) where T: Display` | 境界が多い場合 |

- 複数境界: `T: Display + PartialOrd`

### 戻り値の impl Trait
- `-> impl Summary` で 1 つの具体型のみ返せる
- 条件分岐で別の型を返すのは不可（trait object が必要）

### ブランケット実装
- `impl<T: Display> ToString for T` — Display を実装する全型に ToString を自動実装
- 標準ライブラリで多用されるパターン

### derive で自動実装できるトレイト
| トレイト | 機能 |
|---|---|
| `Debug` | `{:?}` でデバッグ出力 |
| `Clone` | `.clone()` でディープコピー |
| `Copy` | 暗黙コピー（全フィールドが Copy の型のみ） |
| `PartialEq` / `Eq` | `==` / `!=` 比較 |
| `PartialOrd` / `Ord` | `<` `>` `<=` `>=` 比較 |
| `Hash` | HashMap のキーに使える |
| `Default` | デフォルト値の生成 |

## 10.3 ライフタイム

### 基本
- ライフタイム = 参照が有効である期間
- コンパイラがダングリング参照（無効なメモリへの参照）を防ぐ
- `fn longest<'a>(x: &'a str, y: &'a str) -> &'a str`
  - `'a` は x と y の短い方のライフタイムを表す

### ライフタイム省略規則（3つ）
1. 各参照引数にそれぞれ固有のライフタイムが割り当てられる
2. 参照引数が 1 つだけなら、戻り値にもそのライフタイムが付く
3. メソッド（`&self`）なら、戻り値に self のライフタイムが付く

### コンパイラ視点: 省略規則の適用プロセス

コンパイラは関数シグネチャを見て、3つの規則を**順番に**適用する。
すべての参照のライフタイムが決まれば OK、決まらなければコンパイルエラー。

**例1: `fn first_word(s: &str) -> &str`**
```
元:     fn first_word(s: &str) -> &str
規則1:  fn first_word<'a>(s: &'a str) -> &str     // 引数に 'a を割り当て
規則2:  fn first_word<'a>(s: &'a str) -> &'a str  // 引数が1つ → 戻り値にも 'a
→ 全て決定。OK！
```

**例2: `fn longest(x: &str, y: &str) -> &str`**
```
元:     fn longest(x: &str, y: &str) -> &str
規則1:  fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str  // 各引数に固有のライフタイム
規則2:  適用不可（引数が2つ）
規則3:  適用不可（&self がない）
→ 戻り値のライフタイムが決まらない。コンパイルエラー！
→ プログラマが明示的に書く必要がある
```

**例3: `fn announce(&self, msg: &str) -> &str`（メソッド）**
```
元:     fn announce(&self, msg: &str) -> &str
規則1:  fn announce<'a, 'b>(&'a self, msg: &'b str) -> &str
規則2:  適用不可（引数が2つ）
規則3:  fn announce<'a, 'b>(&'a self, msg: &'b str) -> &'a str  // &self の 'a を戻り値に
→ 全て決定。OK！
```

### コンパイラ視点: 借用チェッカー (borrow checker) の推論

借用チェッカーは各参照の**生存区間（ライフタイム）**を追跡し、
「参照が指す先のデータが、参照より先に解放されないか」を検証する。

**具体例で追う:**
```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { ... }

let string1 = String::from("long");   // ----------+-- string1 のスコープ
let result;                            //           |
{                                      //           |
    let string2 = String::from("xy");  // --+-- string2 のスコープ
    result = longest(&string1, &string2);// |
    //               ~~~~~~~~  ~~~~~~~~    |
    //               'a は string1 と      |
    //               string2 の短い方      |
    //               → 'a = string2 の     |
    //                 スコープに縮小       |
}                                      // --+  string2 ドロップ → 'a 終了
// println!("{}", result);             // ← 'a はもう終了しているのでエラー！
```

**チェッカーの思考:**
1. `longest` のシグネチャから、戻り値は `'a` の間だけ有効と知る
2. `'a` は `x` と `y` 両方のライフタイムを満たす必要がある → 短い方に制約される
3. `string2` は内側のブロックで終わる → `'a` もそこで終わる
4. `result` を外側で使おうとすると、`'a` の範囲外 → **エラー**

**重要な直感:**
- ライフタイム注釈はデータの寿命を**変えない**（延ばしも縮めもしない）
- コンパイラに「この参照たちの関係」を**教える**ためのもの
- コンパイラは注釈をもとに「安全に使えるか」を静的に検証する

### 構造体のライフタイム
- 構造体が参照を持つ場合、ライフタイム注釈が必須
- `struct ImportantExcerpt<'a> { part: &'a str }`

### 'static ライフタイム
- プログラム全体の期間にわたって有効
- 文字列リテラルは全て `'static`（バイナリに埋め込まれるため、関数スコープと無関係にずっと存在する）
- 「関数を抜けても生きる」のではなく「そもそもプログラム全体で生きているデータへの参照」
- エラーメッセージで要求されても、本当に必要か慎重に判断すること

### 全要素の統合
```rust
fn longest_with_an_announcement<'a, T>(
    x: &'a str, y: &'a str, ann: T,
) -> &'a str
where T: Display,
```
- ジェネリクス（`T`）+ トレイト境界（`T: Display`）+ ライフタイム（`'a`）を 1 つの関数に
