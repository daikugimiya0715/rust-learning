# 所有権・ムーブ・Copy トレイト・スタックとヒープ

## スタックとヒープ

| | スタック | ヒープ |
|---|---|---|
| 速度 | 速い（LIFO で管理） | 遅い（アロケータが空き領域を探す） |
| サイズ | コンパイル時に確定 | 実行時に決まる |
| 例 | `i32`, `f64`, `bool`, `char`, タプル | `String`, `Vec<T>`, `Box<T>` |

## 所有権の3つのルール

1. 値には**所有者（owner）が1つだけ**ある
2. 所有者がスコープを抜けると、値は**自動で解放**される（`drop` が呼ばれる）
3. 同時に所有者は1つだけ（代入すると所有権が**ムーブ**する）

## ムーブ（Move）

```rust
let s1 = String::from("hello");
let s2 = s1;       // s1 の所有権が s2 にムーブ
// println!("{}", s1);  // コンパイルエラー！s1 はもう使えない
```

- ヒープを使う型（`String` など）は代入でムーブする
- ムーブ後は元の変数が無効になる → 二重解放を防ぐ仕組み

## Copy トレイト

- スタック上の固定サイズ型は **Copy** トレイトを持つ
- Copy がある型は代入時にムーブではなく**コピー**される

```rust
let x = 5;
let y = x;         // コピーされる（ムーブではない）
println!("{}", x); // OK！x はまだ使える
```

### Copy を持つ型の例

- 整数型（`i32`, `u64` など）、浮動小数点型（`f64` など）
- `bool`, `char`
- Copy を持つ型だけで構成されたタプル（例: `(i32, f64)`）

### Copy を持たない型

- `String`, `Vec<T>` などヒープを使う型
- → 代入するとムーブになる

## 参照と借用

```rust
fn calc_length(s: &String) -> usize {  // 借用（所有権を奪わない）
    s.len()
}

let s1 = String::from("hello");
let len = calc_length(&s1);  // &s1 で参照を渡す
println!("{}", s1);           // OK！s1 はまだ使える
```

### 借用のルール

- **不変参照 `&T`**: いくつでも同時に持てる
- **可変参照 `&mut T`**: 同時に1つだけ。他の参照と共存不可
- この制約により**データ競合をコンパイル時に防止**する

## Clone（明示的なディープコピー）

```rust
let s1 = String::from("hello");
let s2 = s1.clone();   // ヒープデータごとコピー
println!("{}", s1);     // OK！s1 もまだ使える
```

- `clone()` はヒープの中身も複製するのでコストが高い
- Copy と違い、明示的に呼ぶ必要がある
