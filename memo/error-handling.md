# エラー処理

## 2026-02-18

### 9-1: `panic!` で回復不能なエラー

- Rust のエラーは大きく2種類：**回復可能**（`Result`）と**回復不能**（`panic!`）
- `panic!` が起きると、エラーメッセージを表示してプログラムが終了する

#### panic の発生源

1. **明示的**: `panic!("メッセージ")` を直接呼ぶ
2. **暗黙的**: 無効な操作（例：`vec![1,2,3][99]` で範囲外アクセス）

#### 巻き戻し（unwind） vs アボート（abort）

- **巻き戻し**（デフォルト）: スタックを遡りながら各関数のデータを片付けてから終了
- **アボート**: 片付けをせず即座に終了。メモリの解放は OS に任せる
- `Cargo.toml` で切り替え可能:
  ```toml
  [profile.release]
  panic = 'abort'
  ```
- abort にすると**バイナリサイズが小さくなる**（巻き戻し用のコードが不要になるため）
- 終了コードも異なる: unwind は `101`、abort は `134`（SIGABRT）

#### バックトレース

- `RUST_BACKTRACE=1` を設定するとパニック時のコールスタックが表示される
- バックトレースは**下から上**に読む（呼び出し順）
- 自分のコードのフレームを探して、そこが原因箇所

#### セキュリティ面

- C 言語では範囲外アクセスは未定義動作（バッファオーバーリード）になる
- Rust はこれをパニックで防ぐ → 安全性の保証

### 9-2: `Result` で回復可能なエラー

#### `Result` の基本

- `File::open` などの戻り値は `Result<T, E>`（`Ok(T)` または `Err(E)`）
- `match` で `Ok` / `Err` を分岐して処理する

#### `ErrorKind` でエラーを分類

- `error.kind()` で `ErrorKind` を取得し、エラーの種類ごとに処理を分けられる
- 例: `ErrorKind::NotFound` → ファイル作成、その他 → panic

#### `unwrap` と `expect`

- `unwrap()`: `Ok` なら値を返し、`Err` なら panic
- `expect("メッセージ")`: `unwrap` と同じだが、panic 時にカスタムメッセージを表示
- **本番コードでは `expect` が推奨**（なぜ失敗したかの文脈がわかるため）

#### エラーの委譲（propagation）

- 関数内でエラーを処理せず、呼び出し元に返すパターン
- `match` 版: `Err(e) => return Err(e)` と明示的に書く（冗長）

#### `?` 演算子

- `?` は `match` + `return Err(e)` のショートカット
- `Ok` なら値を取り出し、`Err` なら関数から即座にリターン
- `?` は `From` トレイトを通じてエラー型の変換も行う
- メソッドチェーンで連結可能: `File::open("x")?.read_to_string(&mut s)?`
- `fs::read_to_string()` で「ファイルを開いて読む」を1行にできる

#### `main` で `?` を使う

- `main() -> Result<(), Box<dyn Error>>` とすれば `main` でも `?` が使える
- `Box<dyn Error>` は**あらゆるエラー型**を受け取れるトレイトオブジェクト
- `Err` の場合はデバッグ出力でエラーが表示され、終了コード 1 で終了

#### `?` と `Option`

- `?` は `Result` だけでなく `Option` にも使える
- `Some` なら値を取り出し、`None` なら早期リターンで `None` を返す
- ただし `Result` を返す関数で `Option` に `?` は使えない（型が違うため）

### 9-3: `panic!` すべきかするまいか

#### `unwrap` / `expect` が適切な場面

- **プロトタイプ・例示・テストコード**では `unwrap` / `expect` で OK
- **コンパイラより人間が多くの情報を持っているとき**も OK
  - 例: ハードコードされた `"127.0.0.1".parse::<IpAddr>()` は絶対成功する
- `expect` には**なぜ成功するはずなのか**の理由を書く
  - 悪い例: `.expect("parse failed")`
  - 良い例: `.expect("ハードコードされたIPアドレスは常に有効であるべき")`

#### `panic!` すべきとき

- **不正な状態（contract 違反）**: 呼び出し側のバグ、前提条件が破られた
- **回復不能な論理エラー**: 到達不能なはずの分岐に到達した
- バグが見つかったとき、呼び出し側に「あなたのコードにバグがある」と伝える手段

#### `Result` を返すべきとき

- **失敗が予測可能**: ユーザー入力のパース、外部リソースへのアクセス
- **呼び出し側に判断を委ねたい**: エラーの回復方法は呼び出し元が知っている

#### 検証のための独自型（Guess パターン）

- フィールドを**非公開**にし、`new()` で値を検証する
- 不正な値なら `panic!`（型が存在する = 値が有効の保証）
- `value()` ゲッターで読み取り専用アクセスを提供
- **型システムで不正な値の存在を防ぐ** → 以降のコードで範囲チェックが不要になる
